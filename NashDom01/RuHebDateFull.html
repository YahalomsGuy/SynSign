<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" > <!--  content="IE=edge" -->
    <title>Yahalom Home</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

</head>

<body>
    <table width="100%">
        <tr>
            <td width="50%">
                <div id="heDateHeb" style="font-size: 50px; color: green; font-weight: bold; text-align: left;">
                   without Strict Mode
                </div>

            </td>
         

            <td width="50%">
                <div id="ruDate" style="font-size: 50px;text-align: left; color: green; font-weight: bold;">
                </div>
            </td>
        </tr>
    </table>
    <br>
<script>
(function() {
    /*! @hebcal/core v3.29.0 */
    var hebcal = function(t) {
        //"use strict"; //by Guy
        var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
            r = function(t) {
                return t && t.Math == Math && t
            },
            n = r("object" == typeof globalThis && globalThis) || r("object" == typeof window && window) || r("object" == typeof self && self) || r("object" == typeof e && e) || function() {
                return this
            }() || Function("return this")(),
            a = {},
            o = function(t) {
                try {
                    return !!t()
                } catch (t) {
                    return !0
                }
            },
            i = !o((function() {
                return 7 != Object.defineProperty({}, 1, {
                    get: function() {
                        return 7
                    }
                })[1]
            })),
            s = Function.prototype.call,
            u = s.bind ? s.bind(s) : function() {
                return s.apply(s, arguments)
            },
            c = {},
            h = {}.propertyIsEnumerable,
            f = Object.getOwnPropertyDescriptor,
            l = f && !h.call({
                1: 2
            }, 1);
        c.f = l ? function(t) {
            var e = f(this, t);
            return !!e && e.enumerable
        } : h;
        var y, d, p = function(t, e) {
                return {
                    enumerable: !(1 & t),
                    configurable: !(2 & t),
                    writable: !(4 & t),
                    value: e
                }
            },
            g = Function.prototype,
            m = g.bind,
            b = g.call,
            v = m && m.bind(b),
            w = m ? function(t) {
                return t && v(b, t)
            } : function(t) {
                return t && function() {
                    return b.apply(t, arguments)
                }
            },
            M = w,
            S = M({}.toString),
            O = M("".slice),
            I = function(t) {
                return O(S(t), 8, -1)
            },
            D = w,
            L = o,
            T = I,
            E = n.Object,
            Y = D("".split),
            N = L((function() {
                return !E("z").propertyIsEnumerable(0)
            })) ? function(t) {
                return "String" == T(t) ? Y(t, "") : E(t)
            } : E,
            j = n.TypeError,
            A = function(t) {
                if (null == t) throw j("Can't call method on " + t);
                return t
            },
            F = N,
            x = A,
            k = function(t) {
                return F(x(t))
            },
            C = function(t) {
                return "function" == typeof t
            },
            P = C,
            z = function(t) {
                return "object" == typeof t ? null !== t : P(t)
            },
            _ = n,
            H = C,
            R = function(t) {
                return H(t) ? t : void 0
            },
            U = function(t, e) {
                return arguments.length < 2 ? R(_[t]) : _[t] && _[t][e]
            },
            V = w({}.isPrototypeOf),
            B = n,
            K = U("navigator", "userAgent") || "",
            G = B.process,
            $ = B.Deno,
            J = G && G.versions || $ && $.version,
            q = J && J.v8;
        q && (d = (y = q.split("."))[0] > 0 && y[0] < 4 ? 1 : +(y[0] + y[1])), !d && K && (!(y = K.match(/Edge\/(\d+)/)) || y[1] >= 74) && (y = K.match(/Chrome\/(\d+)/)) && (d = +y[1]);
        var W = d,
            X = o,
            Z = !!Object.getOwnPropertySymbols && !X((function() {
                var t = Symbol();
                return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && W && W < 41
            })),
            Q = Z && !Symbol.sham && "symbol" == typeof Symbol.iterator,
            tt = U,
            et = C,
            rt = V,
            nt = Q,
            at = n.Object,
            ot = nt ? function(t) {
                return "symbol" == typeof t
            } : function(t) {
                var e = tt("Symbol");
                return et(e) && rt(e.prototype, at(t))
            },
            it = n.String,
            st = C,
            ut = function(t) {
                try {
                    return it(t)
                } catch (t) {
                    return "Object"
                }
            },
            ct = n.TypeError,
            ht = function(t) {
                if (st(t)) return t;
                throw ct(ut(t) + " is not a function")
            },
            ft = u,
            lt = C,
            yt = z,
            dt = n.TypeError,
            pt = {
                exports: {}
            },
            gt = n,
            mt = Object.defineProperty,
            bt = function(t, e) {
                try {
                    mt(gt, t, {
                        value: e,
                        configurable: !0,
                        writable: !0
                    })
                } catch (r) {
                    gt[t] = e
                }
                return e
            },
            vt = bt,
            wt = "__core-js_shared__",
            Mt = n[wt] || vt(wt, {}),
            St = Mt;
        (pt.exports = function(t, e) {
            return St[t] || (St[t] = void 0 !== e ? e : {})
        })("versions", []).push({
            version: "3.19.1",
            mode: "global",
            copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
        });
        var Ot = A,
            It = n.Object,
            Dt = function(t) {
                return It(Ot(t))
            },
            Lt = w({}.hasOwnProperty),
            Tt = Object.hasOwn || function(t, e) {
                return Lt(Dt(t), e)
            },
            Et = w,
            Yt = 0,
            Nt = Math.random(),
            jt = Et(1..toString),
            At = function(t) {
                return "Symbol(" + (void 0 === t ? "" : t) + ")_" + jt(++Yt + Nt, 36)
            },
            Ft = n,
            xt = pt.exports,
            kt = Tt,
            Ct = At,
            Pt = Z,
            zt = Q,
            _t = xt("wks"),
            Ht = Ft.Symbol,
            Rt = Ht && Ht.for,
            Ut = zt ? Ht : Ht && Ht.withoutSetter || Ct,
            Vt = function(t) {
                if (!kt(_t, t) || !Pt && "string" != typeof _t[t]) {
                    var e = "Symbol." + t;
                    Pt && kt(Ht, t) ? _t[t] = Ht[t] : _t[t] = zt && Rt ? Rt(e) : Ut(e)
                }
                return _t[t]
            },
            Bt = u,
            Kt = z,
            Gt = ot,
            $t = function(t, e) {
                var r = t[e];
                return null == r ? void 0 : ht(r)
            },
            Jt = function(t, e) {
                var r, n;
                if ("string" === e && lt(r = t.toString) && !yt(n = ft(r, t))) return n;
                if (lt(r = t.valueOf) && !yt(n = ft(r, t))) return n;
                if ("string" !== e && lt(r = t.toString) && !yt(n = ft(r, t))) return n;
                throw dt("Can't convert object to primitive value")
            },
            qt = Vt,
            Wt = n.TypeError,
            Xt = qt("toPrimitive"),
            Zt = function(t, e) {
                if (!Kt(t) || Gt(t)) return t;
                var r, n = $t(t, Xt);
                if (n) {
                    if (void 0 === e && (e = "default"), r = Bt(n, t, e), !Kt(r) || Gt(r)) return r;
                    throw Wt("Can't convert object to primitive value")
                }
                return void 0 === e && (e = "number"), Jt(t, e)
            },
            Qt = ot,
            te = function(t) {
                var e = Zt(t, "string");
                return Qt(e) ? e : e + ""
            },
            ee = z,
            re = n.document,
            ne = ee(re) && ee(re.createElement),
            ae = function(t) {
                return ne ? re.createElement(t) : {}
            },
            oe = !i && !o((function() {
                return 7 != Object.defineProperty(ae("div"), "a", {
                    get: function() {
                        return 7
                    }
                }).a
            })),
            ie = i,
            se = u,
            ue = c,
            ce = p,
            he = k,
            fe = te,
            le = Tt,
            ye = oe,
            de = Object.getOwnPropertyDescriptor;
        a.f = ie ? de : function(t, e) {
            if (t = he(t), e = fe(e), ye) try {
                return de(t, e)
            } catch (t) {}
            if (le(t, e)) return ce(!se(ue.f, t, e), t[e])
        };
        var pe = {},
            ge = n,
            me = z,
            be = ge.String,
            ve = ge.TypeError,
            we = function(t) {
                if (me(t)) return t;
                throw ve(be(t) + " is not an object")
            },
            Me = i,
            Se = oe,
            Oe = we,
            Ie = te,
            De = n.TypeError,
            Le = Object.defineProperty;
        pe.f = Me ? Le : function(t, e, r) {
            if (Oe(t), e = Ie(e), Oe(r), Se) try {
                return Le(t, e, r)
            } catch (t) {}
            if ("get" in r || "set" in r) throw De("Accessors not supported");
            return "value" in r && (t[e] = r.value), t
        };
        var Te = pe,
            Ee = p,
            Ye = i ? function(t, e, r) {
                return Te.f(t, e, Ee(1, r))
            } : function(t, e, r) {
                return t[e] = r, t
            },
            Ne = {
                exports: {}
            },
            je = C,
            Ae = Mt,
            Fe = w(Function.toString);
        je(Ae.inspectSource) || (Ae.inspectSource = function(t) {
            return Fe(t)
        });
        var xe, ke, Ce, Pe = Ae.inspectSource,
            ze = C,
            _e = Pe,
            He = n.WeakMap,
            Re = ze(He) && /native code/.test(_e(He)),
            Ue = pt.exports,
            Ve = At,
            Be = Ue("keys"),
            Ke = {},
            Ge = Re,
            $e = n,
            Je = w,
            qe = z,
            We = Ye,
            Xe = Tt,
            Ze = Mt,
            Qe = function(t) {
                return Be[t] || (Be[t] = Ve(t))
            },
            tr = Ke,
            er = "Object already initialized",
            rr = $e.TypeError,
            nr = $e.WeakMap;
        if (Ge || Ze.state) {
            var ar = Ze.state || (Ze.state = new nr),
                or = Je(ar.get),
                ir = Je(ar.has),
                sr = Je(ar.set);
            xe = function(t, e) {
                if (ir(ar, t)) throw new rr(er);
                return e.facade = t, sr(ar, t, e), e
            }, ke = function(t) {
                return or(ar, t) || {}
            }, Ce = function(t) {
                return ir(ar, t)
            }
        } else {
            var ur = Qe("state");
            tr[ur] = !0, xe = function(t, e) {
                if (Xe(t, ur)) throw new rr(er);
                return e.facade = t, We(t, ur, e), e
            }, ke = function(t) {
                return Xe(t, ur) ? t[ur] : {}
            }, Ce = function(t) {
                return Xe(t, ur)
            }
        }
        var cr = {
                set: xe,
                get: ke,
                has: Ce,
                enforce: function(t) {
                    return Ce(t) ? ke(t) : xe(t, {})
                },
                getterFor: function(t) {
                    return function(e) {
                        var r;
                        if (!qe(e) || (r = ke(e)).type !== t) throw rr("Incompatible receiver, " + t + " required");
                        return r
                    }
                }
            },
            hr = i,
            fr = Tt,
            lr = Function.prototype,
            yr = hr && Object.getOwnPropertyDescriptor,
            dr = fr(lr, "name"),
            pr = dr && "something" === function() {}.name,
            gr = dr && (!hr || hr && yr(lr, "name").configurable),
            mr = n,
            br = C,
            vr = Tt,
            wr = Ye,
            Mr = bt,
            Sr = Pe,
            Or = {
                EXISTS: dr,
                PROPER: pr,
                CONFIGURABLE: gr
            }.CONFIGURABLE,
            Ir = cr.get,
            Dr = cr.enforce,
            Lr = String(String).split("String");
        (Ne.exports = function(t, e, r, n) {
            var a, o = !!n && !!n.unsafe,
                i = !!n && !!n.enumerable,
                s = !!n && !!n.noTargetGet,
                u = n && void 0 !== n.name ? n.name : e;
            br(r) && ("Symbol(" === String(u).slice(0, 7) && (u = "[" + String(u).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!vr(r, "name") || Or && r.name !== u) && wr(r, "name", u), (a = Dr(r)).source || (a.source = Lr.join("string" == typeof u ? u : ""))), t !== mr ? (o ? !s && t[e] && (i = !0) : delete t[e], i ? t[e] = r : wr(t, e, r)) : i ? t[e] = r : Mr(e, r)
        })(Function.prototype, "toString", (function() {
            return br(this) && Ir(this).source || Sr(this)
        }));
        var Tr = {},
            Er = Math.ceil,
            Yr = Math.floor,
            Nr = function(t) {
                var e = +t;
                return e != e || 0 === e ? 0 : (e > 0 ? Yr : Er)(e)
            },
            jr = Nr,
            Ar = Math.max,
            Fr = Math.min,
            xr = Nr,
            kr = Math.min,
            Cr = function(t) {
                return t > 0 ? kr(xr(t), 9007199254740991) : 0
            },
            Pr = k,
            zr = function(t, e) {
                var r = jr(t);
                return r < 0 ? Ar(r + e, 0) : Fr(r, e)
            },
            _r = function(t) {
                return Cr(t.length)
            },
            Hr = function(t) {
                return function(e, r, n) {
                    var a, o = Pr(e),
                        i = _r(o),
                        s = zr(n, i);
                    if (t && r != r) {
                        for (; i > s;)
                            if ((a = o[s++]) != a) return !0
                    } else
                        for (; i > s; s++)
                            if ((t || s in o) && o[s] === r) return t || s || 0;
                    return !t && -1
                }
            },
            Rr = {
                includes: Hr(!0),
                indexOf: Hr(!1)
            },
            Ur = Tt,
            Vr = k,
            Br = Rr.indexOf,
            Kr = Ke,
            Gr = w([].push),
            $r = function(t, e) {
                var r, n = Vr(t),
                    a = 0,
                    o = [];
                for (r in n) !Ur(Kr, r) && Ur(n, r) && Gr(o, r);
                for (; e.length > a;) Ur(n, r = e[a++]) && (~Br(o, r) || Gr(o, r));
                return o
            },
            Jr = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype");
        Tr.f = Object.getOwnPropertyNames || function(t) {
            return $r(t, Jr)
        };
        var qr = {};
        qr.f = Object.getOwnPropertySymbols;
        var Wr = U,
            Xr = Tr,
            Zr = qr,
            Qr = we,
            tn = w([].concat),
            en = Wr("Reflect", "ownKeys") || function(t) {
                var e = Xr.f(Qr(t)),
                    r = Zr.f;
                return r ? tn(e, r(t)) : e
            },
            rn = Tt,
            nn = en,
            an = a,
            on = pe,
            sn = o,
            un = C,
            cn = /#|\.prototype\./,
            hn = function(t, e) {
                var r = ln[fn(t)];
                return r == dn || r != yn && (un(e) ? sn(e) : !!e)
            },
            fn = hn.normalize = function(t) {
                return String(t).replace(cn, ".").toLowerCase()
            },
            ln = hn.data = {},
            yn = hn.NATIVE = "N",
            dn = hn.POLYFILL = "P",
            pn = hn,
            gn = n,
            mn = a.f,
            bn = Ye,
            vn = Ne.exports,
            wn = bt,
            Mn = function(t, e) {
                for (var r = nn(e), n = on.f, a = an.f, o = 0; o < r.length; o++) {
                    var i = r[o];
                    rn(t, i) || n(t, i, a(e, i))
                }
            },
            Sn = pn,
            On = {};
        On[Vt("toStringTag")] = "z";
        var In = n,
            Dn = "[object z]" === String(On),
            Ln = C,
            Tn = I,
            En = Vt("toStringTag"),
            Yn = In.Object,
            Nn = "Arguments" == Tn(function() {
                return arguments
            }()),
            jn = Dn ? Tn : function(t) {
                var e, r, n;
                return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof(r = function(t, e) {
                    try {
                        return t[e]
                    } catch (t) {}
                }(e = Yn(t), En)) ? r : Nn ? Tn(e) : "Object" == (n = Tn(e)) && Ln(e.callee) ? "Arguments" : n
            },
            An = n.String,
            Fn = function(t) {
                if ("Symbol" === jn(t)) throw TypeError("Cannot convert a Symbol value to a string");
                return An(t)
            },
            xn = "\t\n\v\f\r                　\u2028\u2029\ufeff",
            kn = A,
            Cn = Fn,
            Pn = w("".replace),
            zn = "[\t\n\v\f\r                　\u2028\u2029\ufeff]",
            _n = RegExp("^" + zn + zn + "*"),
            Hn = RegExp(zn + zn + "*$"),
            Rn = function(t) {
                return function(e) {
                    var r = Cn(kn(e));
                    return 1 & t && (r = Pn(r, _n, "")), 2 & t && (r = Pn(r, Hn, "")), r
                }
            },
            Un = {
                start: Rn(1),
                end: Rn(2),
                trim: Rn(3)
            },
            Vn = n,
            Bn = o,
            Kn = w,
            Gn = Fn,
            $n = Un.trim,
            Jn = xn,
            qn = Vn.parseInt,
            Wn = Vn.Symbol,
            Xn = Wn && Wn.iterator,
            Zn = /^[+-]?0x/i,
            Qn = Kn(Zn.exec),
            ta = 8 !== qn(Jn + "08") || 22 !== qn(Jn + "0x16") || Xn && !Bn((function() {
                qn(Object(Xn))
            })) ? function(t, e) {
                var r = $n(Gn(t));
                return qn(r, e >>> 0 || (Qn(Zn, r) ? 16 : 10))
            } : qn;
        (function(t, e) {
            var r, n, a, o, i, s = t.target,
                u = t.global,
                c = t.stat;
            if (r = u ? gn : c ? gn[s] || wn(s, {}) : (gn[s] || {}).prototype)
                for (n in e) {
                    if (o = e[n], a = t.noTargetGet ? (i = mn(r, n)) && i.value : r[n], !Sn(u ? n : s + (c ? "." : "#") + n, t.forced) && void 0 !== a) {
                        if (typeof o == typeof a) continue;
                        Mn(o, a)
                    }(t.sham || a && a.sham) && bn(o, "sham", !0), vn(r, n, o, t)
                }
        })({
            global: !0,
            forced: parseInt != ta
        }, {
            parseInt: ta
        });

        function ea(t) {
            switch (t) {
                case 1:
                    return "א";
                case 2:
                    return "ב";
                case 3:
                    return "ג";
                case 4:
                    return "ד";
                case 5:
                    return "ה";
                case 6:
                    return "ו";
                case 7:
                    return "ז";
                case 8:
                    return "ח";
                case 9:
                    return "ט";
                case 10:
                    return "י";
                case 20:
                    return "כ";
                case 30:
                    return "ל";
                case 40:
                    return "מ";
                case 50:
                    return "נ";
                case 60:
                    return "ס";
                case 70:
                    return "ע";
                case 80:
                    return "פ";
                case 90:
                    return "צ";
                case 100:
                    return "ק";
                case 200:
                    return "ר";
                case 300:
                    return "ש";
                case 400:
                    return "ת";
                default:
                    return "*INVALID*"
            }
        }

        function ra(t) {
            var e = parseInt(t, 10); //changed from let to var
            if (!e) throw new TypeError("invalid parameter to gematriya ".concat(t));
            const r = [];
            for (e %= 1e3; e > 0;) {
                if (15 === e || 16 === e) {
                    r.push(9), r.push(e - 9);
                    break
                }
                let t, n = 100;
                for (t = 400; t > e; t -= n) t === n && (n /= 10);
                r.push(t), e -= t;
            }
            if (1 == r.length) return ea(r[0]) + "׳";
            let n = "";
            for (let t = 0; t < r.length; t++) t + 1 === r.length && (n += "״"), n += ea(r[t]);
            return n
        }
        const na = [
            [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
            [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        ];

        function aa(t, e) {
            return t - e * Math.floor(t / e)
        }

        function oa(t, e) {
            return Math.floor(t / e)
        }
        const ia = {
                monthNames: ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                isLeapYear: function(t) {
                    return !(t % 4 || !(t % 100) && t % 400)
                },
                daysInMonth: function(t, e) {
                    return na[+this.isLeapYear(e)][t]
                },
                isDate: function(t) {
                    return "object" == typeof t && Date.prototype === t.__proto__
                },
                dayOfYear: function(t) {
                    if (!this.isDate(t)) throw new TypeError("Argument to greg.dayOfYear not a Date");
                    let e = t.getDate() + 31 * t.getMonth();
                    return t.getMonth() > 1 && (e -= Math.floor((4 * (t.getMonth() + 1) + 23) / 10), this.isLeapYear(t.getFullYear()) && e++), e
                },
                greg2abs: function(t) {
                    if (!this.isDate(t)) throw new TypeError("Argument to greg.greg2abs not a Date");
                    const e = t.getFullYear() - 1;
                    return this.dayOfYear(t) + 365 * e + (Math.floor(e / 4) - Math.floor(e / 100) + Math.floor(e / 400))
                },
                yearFromFixed: function(t) {
                    const e = t - 1,
                        r = oa(e, 146097),
                        n = aa(e, 146097),
                        a = oa(n, 36524),
                        o = aa(n, 36524),
                        i = oa(o, 1461),
                        s = oa(aa(o, 1461), 365),
                        u = 400 * r + 100 * a + 4 * i + s;
                    return 4 != a && 4 != s ? u + 1 : u
                },
                toFixed: function(t, e, r) {
                    const n = t - 1;
                    return 0 + 365 * n + oa(n, 4) - oa(n, 100) + oa(n, 400) + oa(367 * e - 362, 12) + Math.floor(e <= 2 ? 0 : this.isLeapYear(t) ? -1 : -2) + r
                },
                abs2greg: function(t) {
                    if ("number" != typeof t) throw new TypeError("Argument to greg.abs2greg not a Number");
                    t = Math.trunc(t);
                    const e = this.yearFromFixed(t),
                        r = oa(12 * (t - this.toFixed(e, 1, 1) + (t < this.toFixed(e, 3, 1) ? 0 : this.isLeapYear(e) ? 1 : 2)) + 373, 367),
                        n = t - this.toFixed(e, r, 1) + 1,
                        a = new Date(e, r - 1, n);
                    return e < 100 && e >= 0 && a.setFullYear(e), a
                }
            },
            sa = {
                headers: {
                    "plural-forms": "nplurals=2; plural=(n!=1);"
                },
                contexts: {
                    "": {}
                }
            },
            ua = {
                h: "he",
                a: "ashkenazi",
                s: "en",
                "": "en"
            },
            ca = {
                locales: Object.create(null),
                activeLocale: null,
                activeName: null,
                lookupTranslation: function(t, e) {
                    const r = e && e.toLowerCase(),
                        n = ("string" == typeof e && this.locales[r] || this.activeLocale)[t];
                    if (n && n.length && n[0].length) return n[0]
                },
                gettext: function(t, e) {
                    const r = this.lookupTranslation(t, e);
                    return void 0 === r ? t : r
                },
                addLocale: function(t, e) {
                    if ("object" != typeof e.contexts || "object" != typeof e.contexts[""]) throw new TypeError("Locale '".concat(t, "' invalid compact format"));
                    this.locales[t.toLowerCase()] = e.contexts[""]
                },
                useLocale: function(t) {
                    const e = t.toLowerCase(),
                        r = this.locales[e];
                    if (!r) throw new RangeError("Locale '".concat(t, "' not found"));
                    return this.activeName = ua[e] || e, this.activeLocale = r, this.activeLocale
                },
                getLocaleName: function() {
                    return this.activeName
                },
                ordinal: function(t, e) {
                    const r = e && e.toLowerCase() || this.activeName;
                    if (!r) return this.getEnOrdinal(t);
                    switch (r) {
                        case "en":
                        case "s":
                        case "a":
                        case "ashkenazi":
                        case "ashkenazi_litvish":
                        case "ashkenazi_poylish":
                        case "ashkenazi_standard":
                            return this.getEnOrdinal(t);
                        case "es":
                            return t + "º";
                        case "h":
                        case "he":
                        case "he-x-nonikud":
                            return String(t);
                        default:
                            return t + "."
                    }
                },
                getEnOrdinal: function(t) {
                    const e = ["", "", "", ""],
                        r = t % 100;
                    return t + (e[(r - 20) % 10] || e[r] || e[0])
                },
                hebrewStripNikkud: function(t) {
                    return t.replace(/[\u0590-\u05bd]/g, "").replace(/[\u05bf-\u05c7]/g, "")
                }
            };
        ca.addLocale("en", sa), ca.addLocale("s", sa), ca.addLocale("", sa), ca.useLocale("en");
        const ha = ["", "Нисан", "Ияр", "Сиван", "Тамуз", "Ав", "Элул", "Тишрей", "Хешван", "Кислев", "Тевет", "Шват"],
            fa = [ha.concat(["Адар", "Нисан"]), ha.concat(["Адар 1", "Адар 2", "Нисан"])];

        function la(t) {
            throw new TypeError(t)
        }
        const ya = Object.create(null),
            da = -1373428,
            pa = "day",
            ga = "week",
            ma = "month",
            ba = "year",
            va = {
                d: pa,
                w: ga,
                M: ma,
                y: ba
            },
            wa = {
                day: pa,
                week: ga,
                month: ma,
                year: ba
            };
        class Ma {
            constructor(t, e, r) {
                if (2 == arguments.length || arguments.length > 3) throw new TypeError("HDate constructor requires 0, 1 or 3 arguments");
                if (3 == arguments.length) {
                    if (this.day = this.month = 1, this.year = +r, isNaN(this.year)) throw new TypeError("HDate called with bad year argument: ".concat(r));
                    if (this.setMonth(e), this.setDate(+t), isNaN(this.day)) throw new TypeError("HDate called with bad day argument: ".concat(t))
                } else {
                    void 0 === t && (t = new Date);
                    const e = "number" != typeof t || isNaN(t) ? ia.isDate(t) ? ia.greg2abs(t) : Ma.isHDate(t) ? {
                            dd: t.day,
                            mm: t.month,
                            yy: t.year
                        } : la("HDate called with bad argument: ".concat(t)) : t,
                        r = "number" == typeof e,
                        n = r ? Ma.abs2hebrew(e) : e;
                    this.day = n.dd, this.month = n.mm, this.year = n.yy, r && (this.abs0 = e)
                }
            }
            getFullYear() {
                return this.year
            }
            isLeapYear() {
                return Ma.isLeapYear(this.year)
            }
            getMonth() {
                return this.month
            }
            getTishreiMonth() {
                const t = Ma.monthsInYear(this.getFullYear());
                return (this.getMonth() + t - 6) % t || t
            }
            daysInMonth() {
                return Ma.daysInMonth(this.getMonth(), this.getFullYear())
            }
            getDate() {
                return this.day
            }
            getDay() {
                return aa(this.abs(), 7)
            }
            setFullYear(t) {
                return this.year = t, Sa(this), this
            }
            setMonth(t) {
                return this.month = Ma.monthNum(t), Sa(this), this
            }
            setDate(t) {
                return this.day = t, Sa(this), this
            }
            greg() {
                return ia.abs2greg(this.abs())
            }
            abs() {
                return "number" != typeof this.abs0 && (this.abs0 = Ma.hebrew2abs(this.year, this.month, this.day)), this.abs0
            }
            static hebrew2abs(t, e, r) {
                let n = r;
                if (e < 7) {
                    for (let e = 7; e <= Ma.monthsInYear(t); e++) n += Ma.daysInMonth(e, t);
                    for (let r = 1; r < e; r++) n += Ma.daysInMonth(r, t)
                } else
                    for (let r = 7; r < e; r++) n += Ma.daysInMonth(r, t);
                return da + Ma.elapsedDays(t) + n - 1
            }
            static newYear(t) {
                return da + Ma.elapsedDays(t) + Ma.newYearDelay(t)
            }
            static newYearDelay(t) {
                const e = Ma.elapsedDays(t);
                if (Ma.elapsedDays(t + 1) - e == 356) return 2;
                return e - Ma.elapsedDays(t - 1) == 382 ? 1 : 0
            }
            static abs2hebrew(t) {
                if ("number" != typeof t || isNaN(t)) throw new TypeError("invalid parameter to abs2hebrew ".concat(t));
                t = Math.trunc(t);
                let e = Math.floor((t - da) / 365.24682220597794);
                for (; Ma.newYear(e) <= t;) ++e;
                --e;
                let r = t < Ma.hebrew2abs(e, 1, 1) ? 7 : 1;
                for (; t > Ma.hebrew2abs(e, r, Ma.daysInMonth(r, e));) ++r;
                return {
                    yy: e,
                    mm: r,
                    dd: 1 + t - Ma.hebrew2abs(e, r, 1)
                }
            }
            getMonthName() {
                return Ma.getMonthName(this.getMonth(), this.getFullYear())
            }
            render() {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null) || ca.getLocaleName(),
                    r = this.getDate(),
                    n = ca.gettext(this.getMonthName(), e),
                    a = ca.ordinal(r, e),
                    o = Ma.getDayOfTranslation(e),
                    i = "".concat(a).concat(o, " ").concat(n);
                if (t) {
                    const t = this.getFullYear();
                    return "".concat(i, " ").concat(t)
                }
                return i
            }
            static getDayOfTranslation(t) {
                switch (t) {
                    case "en":
                    case "s":
                    case "a":
                    case "ashkenazi":
                        return ""
                }
                const e = ca.lookupTranslation("", t);
                return e ? " " + e : "ashkenazi" === t.substring(0, 9) ? "" : ""
            }
            renderGematriya() {
                const t = this.getDate(),
                    e = ca.gettext(this.getMonthName(), "he"),
                    r = this.getFullYear();
                return ra(t) + " " + e + " " + ra(r)
            }
            before(t) {
                return Ia(t, this, -1)
            }
            onOrBefore(t) {
                return Ia(t, this, 0)
            }
            nearest(t) {
                return Ia(t, this, 3)
            }
            onOrAfter(t) {
                return Ia(t, this, 6)
            }
            after(t) {
                return Ia(t, this, 7)
            }
            next() {
                return new Ma(this.abs() + 1)
            }
            prev() {
                return new Ma(this.abs() - 1)
            }
            add(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "d";
                if (!(t = parseInt(t, 10))) return new Ma(this);
                if (e = Ma.standardizeUnits(e), e === pa) return new Ma(this.abs() + t);
                if (e === ga) return new Ma(this.abs() + 7 * t);
                if (e === ba) return new Ma(this.getDate(), this.getMonth(), this.getFullYear() + t);
                if (e === ma) {
                    let e = new Ma(this);
                    const r = t > 0 ? 1 : -1;
                    t = Math.abs(t);
                    for (let n = 0; n < t; n++) e = new Ma(e.abs() + r * e.daysInMonth());
                    return e
                }
            }
            static standardizeUnits(t) {
                const e = va[t] || String(t || "").toLowerCase().replace(/s$/, "");
                return wa[e] || la("Invalid units '".concat(t, "'"))
            }
            subtract(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "d";
                return this.add(-1 * t, e)
            }
            deltaDays(t) {
                if (!Ma.isHDate(t)) throw new TypeError("Bad argument: ".concat(t));
                return this.abs() - t.abs()
            }
            isSameDate(t) {
                return !!Ma.isHDate(t) && (this.year == t.year && this.month == t.month && this.day == t.day)
            }
            toString() {
                const t = this.getDate(),
                    e = this.getFullYear(),
                    r = this.getMonthName();
                return "".concat(t, " ").concat(r, " ").concat(e)
            }
            static isLeapYear(t) {
                return (1 + 7 * t) % 19 < 7
            }
            static monthsInYear(t) {
                return 12 + Ma.isLeapYear(t)
            }
            static daysInMonth(t, e) {
                return 2 == t || 4 == t || 6 == t || 10 == t || 13 == t || 12 == t && !Ma.isLeapYear(e) || 8 == t && !Ma.longCheshvan(e) || 9 == t && Ma.shortKislev(e) ? 29 : 30
            }
            static getMonthName(t, e) {
                if ("number" != typeof t || t < 1 || t > 14) throw new TypeError("bad month argument ".concat(t));
                return fa[+Ma.isLeapYear(e)][t]
            }
            static monthNum(t) {
                return "number" == typeof t ? t : t.charCodeAt(0) >= 48 && t.charCodeAt(0) <= 57 ? parseInt(t, 10) : Ma.monthFromName(t)
            }
            static elapsedDays(t) {
                return ya[t] = ya[t] || Ma.elapsedDays0(t)
            }
            static elapsedDays0(t) {
                const e = t - 1,
                    r = 235 * Math.floor(e / 19) + e % 19 * 12 + Math.floor((e % 19 * 7 + 1) / 19),
                    n = 204 + r % 1080 * 793,
                    a = 5 + 12 * r + 793 * Math.floor(r / 1080) + Math.floor(n / 1080),
                    o = n % 1080 + a % 24 * 1080,
                    i = 1 + 29 * r + Math.floor(a / 24),
                    s = i + (o >= 19440 || 2 == i % 7 && o >= 9924 && !Ma.isLeapYear(t) || 1 == i % 7 && o >= 16789 && Ma.isLeapYear(e));
                return s + (s % 7 == 0 || s % 7 == 3 || s % 7 == 5)
            }
            static daysInYear(t) {
                return Ma.elapsedDays(t + 1) - Ma.elapsedDays(t)
            }
            static longCheshvan(t) {
                return Ma.daysInYear(t) % 10 == 5
            }
            static shortKislev(t) {
                return Ma.daysInYear(t) % 10 == 3
            }
            static monthFromName(t) {
                if ("number" == typeof t) return t;
                const e = t.toLowerCase();
                switch (e[0]) {
                    case "n":
                    case "נ":
                        if ("o" == e[1]) break;
                        return 1;
                    case "i":
                        return 2;
                    case "e":
                        return 6;
                    case "c":
                    case "ח":
                        return 8;
                    case "k":
                    case "כ":
                        return 9;
                    case "s":
                        switch (e[1]) {
                            case "i":
                                return 3;
                            case "h":
                                return 11
                        }
                        case "t":
                            switch (e[1]) {
                                case "a":
                                    return 4;
                                case "i":
                                    return 7;
                                case "e":
                                    return 10
                            }
                            break;
                        case "a":
                            switch (e[1]) {
                                case "v":
                                    return 5;
                                case "d":
                                    return /(1|[^i]i|a|א)$/i.test(t) ? 12 : 13
                            }
                            break;
                        case "ס":
                            return 3;
                        case "ט":
                            return 10;
                        case "ש":
                            return 11;
                        case "א":
                            switch (e[1]) {
                                case "ב":
                                    return 5;
                                case "ד":
                                    return /(1|[^i]i|a|א)$/i.test(t) ? 12 : 13;
                                case "י":
                                    return 2;
                                case "ל":
                                    return 6
                            }
                            break;
                        case "ת":
                            switch (e[1]) {
                                case "מ":
                                    return 4;
                                case "ש":
                                    return 7
                            }
                }
                throw new RangeError("Unable to parse month name: ".concat(t))
            }
            static dayOnOrBefore(t, e) {
                return e - (e - t) % 7
            }
            static isHDate(t) {
                return null !== t && "object" == typeof t && "number" == typeof t.year && "number" == typeof t.month && "number" == typeof t.day && "function" == typeof t.greg && "function" == typeof t.abs
            }
        }

        function Sa(t) {
            Oa(t),
                function(t) {
                    t.day < 1 && (7 == t.month && (t.year -= 1), t.day += Ma.daysInMonth(t.month, t.year), t.month -= 1, Sa(t));
                    t.day > Ma.daysInMonth(t.month, t.year) && (6 == t.month && (t.year += 1), t.day -= Ma.daysInMonth(t.month, t.year), t.month += 1, Sa(t));
                    Oa(t)
                }(t)
        }

        function Oa(t) {
            13 != t.month || t.isLeapYear() ? t.month < 1 ? (t.month += Ma.monthsInYear(t.year), t.year -= 1, Sa(t)) : t.month > Ma.monthsInYear(t.year) && (t.month -= Ma.monthsInYear(t.year), t.year += 1, Sa(t)) : (t.month -= 1, Sa(t)), delete t.abs0
        }

        function Ia(t, e, r) {
            return new Ma(Ma.dayOnOrBefore(t, e.abs() + r))
        }
        var Da = {
            headers: {
                "plural-forms": "nplurals=2; plural=(n > 1);",
                language: "he"
            },
            contexts: {
                "": {
                    Adar: ["אַדָר"],
                    "Adar I": ["אַדָר א׳"],
                    "Adar II": ["אַדָר ב׳"],
                    Av: ["אָב"],
                    Cheshvan: ["חֶשְׁוָן"],
                    Elul: ["אֱלוּל"],
                    Iyyar: ["אִיָיר"],
                    Kislev: ["כִּסְלֵו"],
                    Nisan: ["נִיסָן"],
                    "Sh'vat": ["שְׁבָט"],
                    Sivan: ["סִיוָן"],
                    Tamuz: ["תַּמּוּז"],
                    Tevet: ["טֵבֵת"],
                    Tishrei: ["תִשְׁרֵי"]
                }
            }
        };
        return ca.addLocale("he", Da), ca.addLocale("h", Da), t.HDate = Ma, t.Locale = ca, t.gematriya = ra, t.greg = ia, t.months = {
            NISAN: 1,
            IYYAR: 2,
            SIVAN: 3,
            TAMUZ: 4,
            AV: 5,
            ELUL: 6,
            TISHREI: 7,
            CHESHVAN: 8,
            KISLEV: 9,
            TEVET: 10,
            SHVAT: 11,
            ADAR_I: 12,
            ADAR_II: 13
        }, t.version = "3.29.0", Object.defineProperty(t, "__esModule", {
            value: !0
        }), t
    }({});

    /* 2021-11-16T17:35:39.782Z */

    var dt = new Date();
    var hd = new hebcal.HDate(dt);
    if (dt.getHours() > 19) {
        hd = hd.next();
    }
    //document.write(hd.render('en'));
    $("#ruDate").html(hd.render('en'));
    //$("#ruDate").html(currDay + " " + ruMonth + ", " + currYear)
})();


</script>
</body>

</html>